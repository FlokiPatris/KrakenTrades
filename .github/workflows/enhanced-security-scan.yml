# File: .github/workflows/appsec-security.yml
# 🧠 14.8 — Clean, CI/CD-friendly, attacker-minded, secure-by-default.

name: "🔐 AppSec — Security & Secrets Scan"

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write  # 🛡️ needed for SARIF uploads

concurrency:
  group: appsec-scan-${{ github.ref }}
  cancel-in-progress: true

env:
  # 🔧 Centralized configuration (no magic constants)
  PYTHON_VERSION: "3.11"
  SARIF_DIR: "sarif-reports"

  # 📦 Tool versions (pin for reproducibility)
  PIP_AUDIT_VERSION: "2.9.0"
  BANDIT_VERSION: "1.8.6"
  GITLEAKS_IMAGE: "zricethezav/gitleaks"
  GITLEAKS_IMAGE_TAG: "8.18.2"
  GITLEAKS_FALLBACK_TAG: "latest"

  # 🔄 Upload SARIF for trusted contexts (avoid exfil in forks)
  UPLOAD_SARIF: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}

  # 🧰 Shell profile for strict mode; CI helpers live in .ci
  BASH_ENV: .ci/bash_env

  # 🔐 Optional: comma-separated required secrets; fail early if missing (e.g. "SNYK_TOKEN,MY_PAT")
  REQUIRED_SECRETS: ""

jobs:
  security:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    defaults:
      run:
        shell: bash

    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1  # ⏩ faster, less surface

      - name: ⚙️ Init shell + helpers
        run: |
          mkdir -p .ci/bin "${SARIF_DIR}"

          # 🧱 Strict, predictable shell
          cat > "${BASH_ENV}" <<'BASHRC'
          set -Eeuo pipefail
          shopt -s lastpipe
          umask 077
          export LC_ALL=C.UTF-8
          export LANG=C.UTF-8
          trap 'c=$?; echo "::error title=Bash error,file=${BASH_SOURCE:-workflow},line=${LINENO}::exit ${c}"; exit ${c}' ERR
          BASHRC

          # 📄 SARIF helpers
          cat > .ci/bin/sarif_utils.sh <<'BASH'
          set -Eeuo pipefail
          write_empty_sarif() { # <file> <tool> <version>
            printf '{"version":"2.1.0","runs":[{"tool":{"driver":{"name":"%s","version":"%s"}},"results":[]}]} \n' "$2" "$3" > "$1"
            chmod 600 "$1" 2>/dev/null || true
          }
          harden_artifact() { chmod 600 "$1" 2>/dev/null || true; }
          json_to_sarif() { # <json_in> <sarif_out> <tool> <version>
            python .ci/bin/pip_audit_to_sarif.py "$1" "$2" "$3" "$4"
          }
          BASH
          chmod 750 .ci/bin/sarif_utils.sh

          # 🐍 Bandit JSON ➜ SARIF (with path normalization for GitHub matching)
          cat > .ci/bin/bandit_to_sarif.py <<'PY'
          from __future__ import annotations
          import json, os
          from typing import Any, Dict, List

          JSON_ENV = "BANDIT_JSON_PATH"
          OUT_DIR_ENV = "SARIF_DIR"
          VER_ENV = "BANDIT_VERSION"
          WORKSPACE_ENV = "GITHUB_WORKSPACE"

          json_path = os.environ.get(JSON_ENV, "")
          out_dir = os.environ.get(OUT_DIR_ENV, "sarif-reports")
          out_file = os.path.join(os.getcwd(), out_dir, "bandit.sarif")
          bandit_ver = os.environ.get(VER_ENV, "unknown")
          repo_root = os.environ.get(WORKSPACE_ENV, os.getcwd()).replace("\\", "/")

          def norm_repo_rel(p: str) -> str:
            p = (p or "").replace("\\", "/")
            while p.startswith("./"):
              p = p[2:]
            if os.path.isabs(p):
              try:
                rel = os.path.relpath(p, repo_root).replace("\\", "/")
                return rel
              except Exception:
                return os.path.basename(p)
            if p.startswith(repo_root.rstrip("/") + "/"):
              return p[len(repo_root.rstrip("/")) + 1 :]
            return p

          try:
            with open(json_path, "r", encoding="utf-8") as fh:
              data: Dict[str, Any] = json.load(fh)
          except Exception:
            data = {}

          results: List[Dict[str, Any]] = data.get("results") or []
          rules: Dict[str, Dict[str, Any]] = {}
          for r in results:
            tid = (r.get("test_id") or "BANDIT").strip()
            name = r.get("test_name") or tid
            if tid not in rules:
              rules[tid] = {
                "id": tid,
                "name": name,
                "shortDescription": {"text": name},
                "helpUri": r.get("more_info") or "",
                "defaultConfiguration": {"level": "warning"},
              }

          def sev_level(s: str | None) -> str:
            m = (s or "").lower()
            if m == "high": return "error"
            if m == "medium": return "warning"
            return "note"

          sarif_results: List[Dict[str, Any]] = []
          for r in results:
            uri = norm_repo_rel(r.get("filename") or "")
            start_line = r.get("line_number") or 1
            sarif_results.append({
              "ruleId": (r.get("test_id") or "BANDIT"),
              "level": sev_level(r.get("issue_severity")),
              "message": {"text": r.get("issue_text") or "Bandit issue"},
              "locations": [{
                "physicalLocation": {
                  "artifactLocation": {"uri": uri},
                  "region": {"startLine": max(1, int(start_line))}
                }
              }],
              "properties": {
                "tags": ["bandit", (r.get("test_name") or "").strip()],
                "severity": (r.get("issue_severity") or "").upper(),
                "confidence": (r.get("issue_confidence") or "").upper(),
                "cwe": (r.get("issue_cwe") or {}).get("id")
              }
            })

          out = {
            "version": "2.1.0",
            "runs": [{
              "tool": {"driver": {
                "name": "bandit",
                "version": bandit_ver,
                "informationUri": "https://bandit.readthedocs.io/",
                "rules": list(rules.values()),
              }},
              "results": sarif_results
            }]
          }

          os.makedirs(out_dir, exist_ok=True)
          with open(out_file, "w", encoding="utf-8") as fh:
            json.dump(out, fh, indent=2)
          PY
          chmod 750 .ci/bin/bandit_to_sarif.py

          # 📦 pip-audit JSON ➜ SARIF (tolerant schema)
          cat > .ci/bin/pip_audit_to_sarif.py <<'PY'
          from __future__ import annotations
          import json, os, sys
          from typing import Any, Dict, List

          def sev_level(s: str | None) -> str:
            m = (s or "").lower()
            if m in ("critical", "high"): return "error"
            if m in ("medium",): return "warning"
            return "note"

          def main() -> int:
            if len(sys.argv) < 5:
              print("usage: pip_audit_to_sarif.py <json_in> <sarif_out> <tool> <version>", file=sys.stderr)
              return 2
            jpath, spath, tool, ver = sys.argv[1:5]
            artifact = os.environ.get("PIP_AUDIT_ARTIFACT_URI", "environment")

            try:
              with open(jpath, "r", encoding="utf-8") as fh:
                data = json.load(fh)
            except Exception:
              data = []

            # Support both list root and {"dependencies": [...]} root
            if isinstance(data, dict):
              deps = data.get("dependencies") or []
            else:
              deps = data or []

            rules: Dict[str, Dict[str, Any]] = {}
            results: List[Dict[str, Any]] = []

            for dep in deps:
              name = dep.get("name") or "unknown"
              version = dep.get("version") or "unknown"
              vulns = dep.get("vulns") or []
              for v in vulns:
                vid = (v.get("id") or "VULN").strip()
                aliases = v.get("aliases") or []
                summary = v.get("description") or v.get("summary") or ""
                adv = v.get("advisory") or {}
                if not summary and isinstance(adv, dict):
                  summary = adv.get("summary") or adv.get("description") or ""
                refs = v.get("references") or adv.get("references") or []
                severity = (v.get("severity") or adv.get("severity") or "").lower()
                fixes = v.get("fix_versions") or []

                if vid not in rules:
                  rules[vid] = {
                    "id": vid,
                    "name": vid,
                    "shortDescription": {"text": summary or vid},
                    "helpUri": refs[0] if isinstance(refs, list) and refs else "",
                    "properties": {"aliases": aliases},
                    "defaultConfiguration": {"level": sev_level(severity)},
                  }

                msg = f"{name} {version}: {vid}"
                if fixes:
                  msg += f" | fix_versions={', '.join(fixes)}"
                if summary:
                  msg += f" | {summary}"

                results.append({
                  "ruleId": vid,
                  "level": sev_level(severity),
                  "message": {"text": msg},
                  "locations": [{
                    "physicalLocation": {
                      "artifactLocation": {"uri": artifact},
                      "region": {"startLine": 1}
                    }
                  }],
                  "properties": {
                    "package": name,
                    "version": version,
                    "severity": severity.upper() if severity else "UNKNOWN",
                    "aliases": aliases,
                    "fix_versions": fixes,
                  }
                })

            out = {
              "version": "2.1.0",
              "runs": [{
                "tool": {"driver": {
                  "name": tool,
                  "version": ver,
                  "informationUri": "https://github.com/pypa/pip-audit",
                  "rules": list(rules.values()),
                }},
                "results": results
              }]
            }

            os.makedirs(os.path.dirname(spath) or ".", exist_ok=True)
            with open(spath, "w", encoding="utf-8") as fh:
              json.dump(out, fh, indent=2)
            return 0

          if __name__ == "__main__":
            raise SystemExit(main())
          PY
          chmod 750 .ci/bin/pip_audit_to_sarif.py

      - name: 🔐 Validate required secrets
        run: |
          if [[ -n "${REQUIRED_SECRETS}" ]]; then
            IFS=',' read -r -a _keys <<< "${REQUIRED_SECRETS}"
            missing=()
            for raw in "${_keys[@]}"; do
              key="${raw//[[:space:]]/}"
              [[ -z "${key}" ]] && continue
              [[ -z "${!key-}" ]] && missing+=("${key}")
            done
            if (( ${#missing[@]} > 0 )); then
              echo "::error title=Missing required secrets::${missing[*]}"
              exit 1
            fi
          fi

      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 🔑 Gitleaks (secrets → SARIF)
        run: |
          source .ci/bin/sarif_utils.sh

          tag="${GITLEAKS_IMAGE_TAG}"
          if ! docker pull "${GITLEAKS_IMAGE}:${tag}" >/dev/null 2>&1; then
            echo "::warning::Gitleaks fallback to ${GITLEAKS_FALLBACK_TAG}"
            tag="${GITLEAKS_FALLBACK_TAG}"
            if ! docker pull "${GITLEAKS_IMAGE}:${tag}" >/dev/null 2>&1; then
              write_empty_sarif "${SARIF_DIR}/gitleaks.sarif" "gitleaks" "$tag"
              exit 0
            fi
          fi

          docker run --rm \
            --user "$(id -u):$(id -g)" \
            --read-only \
            --cap-drop=ALL \
            --network none \
            -v "$PWD:/repo:ro" \
            -v "$PWD/${SARIF_DIR}:/out:rw" \
            -w /repo \
            "${GITLEAKS_IMAGE}:${tag}" detect --no-banner \
              --source /repo \
              --redact \
              --exit-code 1 \
              --report-format sarif \
              --report-path "/out/gitleaks.sarif"

          [[ -s "${SARIF_DIR}/gitleaks.sarif" ]] || \
            write_empty_sarif "${SARIF_DIR}/gitleaks.sarif" "gitleaks" "$tag"

          harden_artifact "${SARIF_DIR}/gitleaks.sarif"

      - name: ⬆️ Upload Gitleaks SARIF
        if: always() && env.UPLOAD_SARIF == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.SARIF_DIR }}/gitleaks.sarif
          category: secrets-gitleaks
          wait-for-processing: true

      # 📦 pip-audit (dependency vulnerabilities → JSON → SARIF, with fail-on-findings)
      - name: 📦 Install pip-audit
        run: |
          python -m pip install --upgrade pip
          pip install --disable-pip-version-check --no-cache-dir "pip-audit==${PIP_AUDIT_VERSION}"

      - name: 📦 Run pip-audit (requirements.txt) → SARIF
        run: |
          source .ci/bin/sarif_utils.sh
          mkdir -p "${SARIF_DIR}"

          json_out="${SARIF_DIR}/pip-audit.json"
          sarif_out="${SARIF_DIR}/pip-audit.sarif"
          audit_status=0

          if [[ -f requirements.txt ]]; then
            pip-audit -r requirements.txt --format json --output "${json_out}" --strict
            audit_status=$?
            export PIP_AUDIT_ARTIFACT_URI="requirements.txt"
          else
            pip-audit --format json --output "${json_out}" --strict
            audit_status=$?
            export PIP_AUDIT_ARTIFACT_URI="environment"
          fi

          if [[ -s "${json_out}" ]]; then
            json_to_sarif "${json_out}" "${sarif_out}" "pip-audit" "${PIP_AUDIT_VERSION}"
          else
            write_empty_sarif "${sarif_out}" "pip-audit" "${PIP_AUDIT_VERSION}"
          fi

          echo "AUDIT_STATUS=${audit_status}" >> "$GITHUB_ENV"
          harden_artifact "${sarif_out}"


      - name: ⬆️ Upload pip-audit SARIF
        if: always() && env.UPLOAD_SARIF == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.SARIF_DIR }}/pip-audit.sarif
          category: deps-pip-audit
          wait-for-processing: true

      - name: ❌ Fail build if pip-audit found vulnerabilities
        if: ${{ env.AUDIT_STATUS != '0' }}
        run: |
          echo "🚨 Vulnerabilities detected by pip-audit — failing pipeline."
          exit 1

      - name: 🐍 Bandit (code security → SARIF)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          source .ci/bin/sarif_utils.sh
          pip install --disable-pip-version-check --no-cache-dir "bandit[toml]==${BANDIT_VERSION}"

          tmpdir="${RUNNER_TEMP:-/tmp}"
          BANDIT_JSON="$(mktemp -p "${tmpdir}" bandit-XXXX.json)"

          bandit -r "${GITHUB_WORKSPACE:-.}" \
                 --severity-level low \
                 -f json \
                 -o "${BANDIT_JSON}" \
                 -q || true

          python - <<'PY'
          import json, os
          p = os.environ.get("BANDIT_JSON","")
          try:
              with open(p,"r",encoding="utf-8") as f:
                  d = json.load(f)
              res = d.get("results") or []
              print(f"::notice title=Bandit::results={len(res)}")
              for r in res[:5]:
                  print(f"::notice title=Bandit sample::{r.get('test_id')} {r.get('issue_severity')} {r.get('filename')}")
          except Exception as e:
              print(f"::warning title=Bandit JSON parse failed::{e}")
          PY

          export BANDIT_JSON_PATH="${BANDIT_JSON}"
          python .ci/bin/bandit_to_sarif.py
          harden_artifact "${SARIF_DIR}/bandit.sarif"

          rm -f -- "${BANDIT_JSON}"

      - name: ⬆️ Upload Bandit SARIF
        if: ${{ env.UPLOAD_SARIF == 'true' }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.SARIF_DIR }}/bandit.sarif
          category: code-bandit
          wait-for-processing: true

      - name: 🧹 Harden artifacts & audit log
        if: always()
        run: |
          chmod -R go= "${SARIF_DIR}" 2>/dev/null || true
          echo "Audit: docker scans used non-root, read-only FS, cap-drop=ALL, network none."
          echo "Audit: no secrets echoed; SARIF files mode 600; uploads gated by UPLOAD_SARIF=${UPLOAD_SARIF}."
